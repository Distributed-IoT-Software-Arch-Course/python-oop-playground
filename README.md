# Python Object-Oriented Programming Playground

This is a playground for Python Object Oriented Programming (OOP) concepts. 
The goal is to provide a hands-on experience with OOP concepts in Python.

The proposed modeling is associated to a Smart Home with various IoT devices: 

- Temperature sensors
- Humidity sensors
- Smart lights

The exercise will involve designing data structure, identify classes (and creating them in Python to model these devices, 
a central system to collect and manage data.

**Note:** The scenario is simplified without any kind of communication, and everything is running within the same process. 

Playground Sections:

- [JSON Introduction](#json-introduction-)
- [Base Classes](#base-classes)
- [Device Class](#device-class)
- [Sensor Class](#sensor-class)
- [Actuator Class](#actuator-class)

## Json Introduction 

JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write, and easy for machines to parse and generate. 
It is a text format that is completely language-independent, making it ideal for data exchange between different systems.

An example of a JSON Datastructure is:

```json
{
  "name": "John Doe",
  "age": 30,
  "city": "New York"
}
```

### Basic components of JSON

Objects:
- Enclosed in curly braces ({}).
- Contain key-value pairs separated by commas.
- Keys are strings (enclosed in double quotes).
- Values can be any valid JSON data type (including objects, arrays, strings, numbers, booleans, or null).

Arrays:
- Enclosed in square brackets ([]).
- Contain ordered lists of values separated by commas.
- Values can be any valid JSON data type.

Data types in JSON:

- Strings: Enclosed in double quotes (").
- Numbers: Can be integers or floating-point numbers.
- Booleans: true or false.
- Null: Represents the absence of a value.

Characteristics of JSON:

- Human-readable: JSON is designed to be easily read and understood by humans.
- Machine-readable: JSON is easily parsed and generated by machines.
- Lightweight: JSON is a relatively small format compared to XML.
- Language-independent: JSON is not tied to any specific programming language.
- Hierarchical: JSON data is organized in a hierarchical structure using objects and arrays.

Example of a basic JSON structure:

```json
{
  "name": "John Doe",
  "age": 30,
  "city": "New York",
  "isStudent": false,
  "hobbies": ["reading", "coding", "traveling"]
}
```

### Import Json Package

Python provides built-in support for JSON through the json module. Here's a brief overview of how to use it:

```python
import json
```

### Load JSON data from a file

This will load the JSON data from the data.json file and store it in the data variable as a Python object (e.g., dictionary, list, or a combination of both).

```python
with open('data.json', 'r') as f:
    data = json.load(f)
```

### Dump data to a JSON file

This will write the Python object data as JSON data to the output.json file.

```python
with open('output.json', 'w') as f:
    json.dump(data, f)
```

### Json & Dictionary

From Dictionary to Json String

```python
data = {
    "name": "Alice",
    "age": 30,
    "city": "New York"
}

json_data = json.dumps(data)
print(json_data)
```

The output will be:

```json
{"name": "Alice", "age": 30, "city": "New York"}
```

From Json String to Dictionary

```python
json_string = '{"name": "Bob", "age": 25, "city": "Los Angeles"}'
python_dict = json.loads(json_string)

print(python_dict["name"])   # Output: Bob
print(python_dict["age"])    # Output: 25
print(python_dict["city"])   # Output: Los Angeles
```

## Base Classes

The basic classes are:

- `Device`: Base class for all devices defining the following attributes for all the devices such as sensors and actuators subclasses:
  - `device_id`: Id of the device
  - `device_type`: Type of the device
  - `device_manufacturer`: Manufacturer of the device
  - The Device class defines two core method that will be inherited by every subclasses: 
    - `get_json_measurement`: Returns a JSON representation of the Status of the device (e.g., the last measurement o the last state of an actuator). This method should be implemented by subclasses.
    - `get_json_description`: Returns a JSON representation of the Device. The Device class already provide a default implementation that can be applied to every device and subclasses (e.g., Sensor and Actuator)
- `Sensor`: Base class for all sensors extending `Device` class and adding: 
  - Methods:
    - `update_measurement()`: update the sensor value. The default implementation throws a `NotImplementedError` exception and the subclasses must implement it. 
  - Attributes:
    - `value`: associated to the current sensor value
    - `unit`: mapping the unit associated to the physical measurement type
    - `timestamp` of the last sample in milliseconds
- `Actuator`: Base class for all actuators extending `Device` class and adding:
  - Methods:
    - `invoke_action(action_type, payload)`: method and the `get_json_description` method to get the description of the sensor in JSON format
  - Attributes:
    -  `status`: associated to the current status of the actuator
    - `timestamp` of the last action in milliseconds

## Device Class

The Device class has the following structure with a constructor to initialize the Device instance and two methods
related to Json description of the device and the associated last measurement.

```python
import json

class Device:
    """ Base class for devices """

    def __init__(self, device_id, device_type, device_manufacturer):
        """ Initialize the devices with a devices ID and a devices type """
        self.device_id = device_id
        self.device_type = device_type
        self.device_manufacturer = device_manufacturer

    def get_json_measurement(self):
        """ Returns a JSON representation of the Status of the device (e.g., the last measurement) """
        raise NotImplementedError("This method should be overridden by subclasses")

    def get_json_description(self):
        """ Returns a JSON representation of the Device """

        result_dict = {
            "device_id": self.device_id,
            "device_type": self.device_type,
            "device_manufacturer": self.device_manufacturer
        }

        return json.dumps(result_dict)
```

The method `get_json_measurement()` is not implemented since depends on the characteristics of the specific subclass
like `Sensor` that returns last measurements (e.g., Temperature) or `Actuator` that instead return the last state.

On the opposite, the method `get_json_description()` provides a default implementation describing the device in 
terms of its `id`, `type`, and `manufacturer`. This implementation is usable by every subclass but of course it can 
be overridden in order to customize or extend the behaviour.

## Sensors & Actuator Classes

The main two Subclasses for Device are `Sensor` and `Actuator` with the following structure

### Sensor Class

The `Sensor` class has the responsibility to map the properties and behaviours of the Sensors in our system and application.

```python
from .device import Device
import json

class Sensor(Device):
    """ Base class for sensors """

    def __init__(self, device_id, device_type, device_manufacturer):
        """ Initialize the sensor with a devices ID, a devices type """
        super().__init__(device_id, device_type, device_manufacturer)

        # Initialize the measurement value to None and the timestamp
        # Subclasses should override the update_measurement method to set the value
        self.value = None

        # Set the timestamp to None, subclasses should set the timestamp when updating the measurement
        self.timestamp = None

        # Set the Unit associated to sensor measurements
        self.unit = None
```

Then we declare and add a new method `update_measurement` in charge of structuring how each specific sensor model
the measuring of its new values. For this reason this method is empty and should be overridden by subclasses.

```python
def update_measurement(self):
    """ Update the measurement of the sensor, this method should be overridden by subclasses """
    raise NotImplementedError("This method should be overridden by subclasses")
```

On the other hand, the implementation of the `get_json_measurement` can be integrated in the `Sensor` class and then
inherited by Sensors subclasses defining how sensor measurements are reported as JSON String.

```python
def get_json_measurement(self):
    """ Returns a JSON Measurement of the humidity sensor """
    result_dict = {
        "device_id": self.device_id,
        "value": self.value,
        "unit": self.unit,
        "timestamp": self.timestamp
    }

    return json.dumps(result_dict)
```

### Actuator Class

The `Actuator` class has the responsibility to map the properties and behaviours of the Actuator in our system and application.

```python
from .device import Device
import json

class Actuator(Device):
    """ Base class for actuators """

    def __init__(self, device_id, device_type, device_manufacturer):
        """ Initialize the actuator with a devices ID and a devices type """
        super().__init__(device_id, device_type, device_manufacturer)

        # Initialize the status to None, subclasses should set the status when needed
        self.status = "off"

        # Set the timestamp to None, subclasses should set the timestamp when updating the status
        self.timestamp = None
```

With the following method `invoke_action` we model the behaviour of an Actuator that can receive and action request
and execute it starting from a `type` and a `payload` containing the detail of the action (e.g., `ON` and `OFF`).
In this case since this class is generic, this method is not implemented and should be overridden by subclasses.

```python
def invoke_action(self, action_type, payload):
    """ Invoke an action on the actuator """
    raise NotImplementedError("This method should be overridden by subclasses")
```

The 

```python
def get_json_measurement(self):
    """ Returns a JSON Measurement of the humidity sensor """
    result_dict = {
        "device_id": self.device_id,
        "status": self.status,
        "timestamp": self.timestamp
    }

    return json.dumps(result_dict)
```

## Sensors & Actuator SubClasses

Starting from the base classes, we have the following subclasses:

- `TemperatureSensor`: A sensor that measures temperature extending `Sensor` class and mapping a default initial value of 20.0, unit of Celsius, a timestamp of the last sample in milliseconds.
   , the random value is generated between 20 and 30 degrees with a random increment between -0.5 to 0.5 degrees.
- `HumiditySensor`: A sensor that measures humidity extending `Sensor` class and mapping a default initial value of 50.0, unit of percentage, a timestamp of the last sample in milliseconds.
   , the random value is generated between 40% and 60% percentage with a random increment between -5% to 5%.
- `SmartLight`: An actuator that can be turned on or off extending `Actuator` class and mapping a default initial status of `OFF`, a timestamp of the last action in milliseconds. The `invoke_action(action_type, payload)`
   method check the received action type and if it supported (`SWITCH` value) together with the correct value of the payload (`ON` or `OFF`) change the current value of the actuator and align the associated timestamp.

## Data Management

The class `DataManager` has been defined to shape how data are managed in the application, to centralize the associated methods and 
_hide_ how data and information are effectively stored by the class itself.

The actual implementation has the following main capabilities:

- **Device Management**: allows to store and retrieve Devices for the Smart Home through dedicated method. The adopted data structure is a `list` of devices.
- **Measurement Management**: supports the saving and retrieval of sensor measurements and actuator variations over time.

Implemented and supported methods are:

- `add_device(device)`: Add a new device to the Data Manager
- `remove_device(device_id)`: Remove a device from the Data Manager 
- `get_device(device_id)`: Get a device by its Id from the stored devices on the Data Manager
- `store_measurement(device_id, measurement)`: Store a measurement for a device. It can be associated both a variation of a Sensor or a status change in an actuator
- `get_measurements(device_id)`: Get all measurements for a specific device
- `get_all_measurements()`: Retrieve all the stored measurements

## Smart Home

The Smart Home class is in charge of two main responsibilities: 

- **Device Management**: Exposes the capabilities to manage devices (`add`, `remove`, and `get`) hiding the fact that it is using an instance of the `DataManager` to do that.
- **Measurement Service**: Exposes stored measurements associated to both sensors and actuators hiding the fact that it is using an instance of the `DataManager` to do that.
- **Home Monitoring**: Implements a method to emulate the `monitoring` of the Smart Home that periodically check and update sensors measurements and randomly change actuators status.

## Main Application

The `main.py` file is the entry point of the application. It creates a Smart Home instance and adds some devices to it.
It also starts the monitoring of the Smart Home and prints the measurements of the devices.

```python
    # Create the smart home
    my_smart_home = SmartHome(DataManager(), "SH001", 37.7749, -122.4194)

    # Add devices
    temp_sensor = TemperatureSensor(device_id=1)
    humidity_sensor = HumiditySensor(device_id=2)
    smart_light = SmartLight(device_id=3)

    my_smart_home.add_device(temp_sensor)
    my_smart_home.add_device(humidity_sensor)
    my_smart_home.add_device(smart_light)

    # Get Initial Status of all devices
    print("\nInitial Status of IoT Devices:")
    for device in my_smart_home.get_all_devices():
        # Check if the devices is a sensor or an actuator and print the value or the status
        if isinstance(device, Sensor):
            print(f'Sensor: {device.device_id} Value: {device.value} Timestamp: {device.timestamp}')
        elif isinstance(device, Actuator):
            print(f'Actuator: {device.device_id} Value: {device.status} Timestamp: {device.timestamp}')

    # Monitor the smart home for 5 seconds
    my_smart_home.monitor_home(seconds=5)

    # Get all stored measurements
    measurements = my_smart_home.get_all_measurements()
    print("\nStored Measurements:")
    for device_id, device_measurements in measurements.items():
        for measurement in device_measurements:
            print(f"Device {device_id} - Measurement: {measurement}")

    # Print Json Description of all devices
    print("\nJson Description of all devices:")
    for device in my_smart_home.get_all_devices():
        print(device.get_json_description())
```

## File Organization & Modules

To organize your classes and files into different folders, you can follow these steps:  
Create a Directory Structure: Organize your files into directories based on their functionality. For example:  

```text
smart_home_project/
├── data
    ├── __init__.py
    ├── data_manager.py
├── devices/
│   ├── __init__.py
│   ├── actuator.py
│   ├── sensor.py
│   ├── smart_light.py
├── main.py
├── smart_home.py
└── README.md
```
The `__init__.py` file is used to mark a directory as a Python package. 
This allows you to import modules from that directory. 
Here are the main reasons why you need an `__init__.py` file:  

- **Package Initialization:** It can be used to execute initialization code for the package or set the __all__ variable to control what is imported when from package import * is used.  
- **Namespace Management:** It helps in managing the namespace of the package, ensuring that the modules within the package can be imported correctly.  
- **Compatibility:** In older versions of Python (before 3.3), the presence of __init__.py was required to recognize a directory as a package. Although it is not strictly necessary in Python 3.3 and later, it is still a good practice to include it for compatibility and clarity.

After that you have to update imports adjusting the import statements in your files to reflect the new directory structure.
For example in the `main.py` we will have an updated import for SmartLight class:

```python
from data.data_manager import DataManager
from home.smart_home import SmartHome
from devices.smart_light import SmartLight

[...]
```

If you have an import from a different class within the same directory you should use a relative import
like the following statement: 

```python
from .device import Device
```